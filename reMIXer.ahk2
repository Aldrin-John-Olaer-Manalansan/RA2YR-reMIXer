#SingleInstance Force
#Warn
KeyHistory 0
ListLines False
SetWorkingDir A_ScriptDir

; #include "Lib\MCodes.ahk2"
#DllLoad "%A_ScriptDir%\reMIXer.dll"
DLLHandle := DllCall("GetModuleHandle", "Str", "reMIXer", "Ptr")
if !DLLHandle
{
    MsgBox "Failed to load reMIXer.dll!"
    ExitApp
}
FileConflictChecker := DllCall("GetProcAddress", "Ptr", DLLHandle, "AStr", "FileConflictChecker", "Ptr")
ReconstructMIX := DllCall("GetProcAddress", "Ptr", DLLHandle, "AStr", "ReconstructMIX", "Ptr")

#include "Lib\Class_LV_Colors.ahk2"

AppVersion := "3.1.0.0"

	; ~~~~~~~~~~~~~~~~~~~~~~~~~~~ Construct the Control Panel GUI
Gui_ControlPanel := Gui("OwnDialogs ", "RA2YR reMIXer v" . AppVersion . (A_IsAdmin?" (Administrator)":""))
Gui_ControlPanel.BackColor := "72787E"
Gui_ControlPanel.SetFont("cWhite", "Verdana")
Gui_ControlPanel.AddButton("vAddButton Y10 H20", "Add Target Archives to List")
Gui_ControlPanel["AddButton"].OnEvent("Click", AddMIXtoList)
Gui_ControlPanel.AddButton("vreMIXAllTargets X+m H20", "reMIX All Targets")
Gui_ControlPanel["reMIXAllTargets"].OnEvent("Click", reMIXAllMIXTargets)
Gui_ControlPanel.AddButton("vHowToUse X+m H20", "How to Use RA2YR reMIXer?")
Gui_ControlPanel["HowToUse"].OnEvent("Click", Gui_ControlPanel_HowToUseMsg)
Gui_ControlPanel.AddText("XM Y+10", "Mode:")
Gui_ControlPanel.AddDDL("vModeSelector R3 Choose3 X+2 H20 W" . PercentageToScreenWidth(39.2), ["1: Only Fix Header","2(Recommended): Recover LMD Lookup Table -> Fix Header", "3(Advanced): Reconstruct MIX Archive -> Recover LMD Lookup Table -> Fix Header"])
Gui_ControlPanel.AddListView("vLV Grid Background303841 Checked -LV0x10 -WantF2 Xs Y+10 W" . PercentageToScreenWidth(41) . " H" . PercentageToScreenHeight(45), ["Header Status", "LMD Status", "File Path",""])
Gui_ControlPanel_LV_Menu := Menu()
Gui_ControlPanel_LV_Menu.Add("Delete All Selected Rows", Gui_ControlPanel_LV_DeleteRows)
Gui_ControlPanel_LV_Colors := LV_Colors(Gui_ControlPanel["LV"]) ; Create a new instance of LV_Colors
If !IsObject(Gui_ControlPanel_LV_Colors)
   MsgBox("Couldn't create a new LV_Colors object!", "ERROR", 16)
Gui_ControlPanel_LV_Colors.ShowColors(True)
Gui_ControlPanel["LV"].OnEvent("ContextMenu", Gui_ControlPanel_LV_Menu_Show)
Gui_ControlPanel["LV"].OnEvent("ColClick", Gui_ControlPanel_LV_UpdateColors)
Gui_ControlPanel_Progress := Gui_ControlPanel.AddProgress("-Smooth Range Xs Y+10 W" . PercentageToScreenWidth(41) . " H" . PercentageToScreenHeight(2), 100)
Gui_ControlPanel_Progress.Visible := False
Gui_ControlPanel_Progress.Value := 0
Gui_ControlPanel.OnEvent("DropFiles", DragAndDropMIXesToList)
Gui_ControlPanel.Show("Center")
	; ~~~~~~~~~~~~~~~~~~~~~~~~~~~

	; ~~~~~~~~~~~~~~~~~~~~~~~~~~~ Construct the LMD Selector GUI
Gui_LMDSelector := Gui("AlwaysOnTop OwnDialogs Owner" . Gui_ControlPanel.Hwnd, "LMD Selector")
Gui_LMDSelector.BackColor := "72787E"
Gui_LMDSelector.SetFont("cWhite", "Verdana")
Gui_LMDSelector.AddText("W" . 0.25*A_ScreenWidth,"Multiple LMD files have been detected inside the target MIX Archive:")
Gui_LMDSelector_FilePath := Gui_LMDSelector.AddEdit("ReadOnly Background303841 W" . 0.25*A_ScreenWidth)
Gui_LMDSelector.AddText("W" . 0.25*A_ScreenWidth,"
(

Please select only one among the list.

Legend:
  Offset From Body - distance in address from the body address, where our LMD File can be found.
  Size - LMD File Size in bytes.
  Names Count - how many entries are listed in the dictionary of this LMD File. These entries are used for defining all possible file names that this MIX Archive contain.
  Status:
    * Default - this LMD file is what our MIX Archive is currently using.
    * Unused - this LMD exists inside our MIX Archive but wasn't used by default.

- Keep in mind that selecting a wrong LMD file will result some files to have incorrect names when viewing the mix. If this happens, redo the reMIXing and select another LMD file from the list, until majority of the file names are now viewable at the XCC Mixer Application.
- Close this GUI to finalize your selection
- Closing this GUI without selecting anything from the list will choose the "Default" LMD File. Incase there is no "Default" LMD File, the LMD File with the highest Offset from the Body will be chosen.
)")
Gui_LMDSelector_LV := Gui_LMDSelector.AddListView("Grid Background303841 -LV0x10 -Multi -WantF2 W" . 0.25*A_ScreenWidth . " H" . 0.25*A_ScreenHeight, ["Relative Offset From Body", "Size", "Names Count", "Status",""])
Gui_LMDSelector.OnEvent("Close", LMDSelector_Select)
	; ~~~~~~~~~~~~~~~~~~~~~~~~~~~

	; ~~~~~~~~~~~~~~~~~~~~~~~~~~~ Construct the Conflict Solver GUI
Gui_ConflictSolver := Gui("AlwaysOnTop OwnDialogs Owner" . Gui_ControlPanel.Hwnd, "Conflict Solver")
Gui_ConflictSolver.BackColor := "72787E"
Gui_ConflictSolver.SetFont("cWhite", "Verdana")
Gui_ConflictSolver_Comment := Gui_ConflictSolver.AddEdit("ReadOnly Background303841 W" . PercentageToScreenWidth(50.5) . " H" . PercentageToScreenHeight(20))
Gui_ConflictSolver.AddButton("vCancelMIXReconstruction XM H20 ", "Cancel MIX Reconstruction")
Gui_ConflictSolver["CancelMIXReconstruction"].OnEvent("Click", Gui_ConflictSolver_CancelMIXReconstruction_OnClick)
Gui_ConflictSolver.AddText("vBytesConflict Center Background303841 X+m W" . PercentageToScreenWidth(32.5),"37213217 Bytes Saved")
Gui_ConflictSolver_DuplicateLV := Gui_ConflictSolver.AddListView("Grid Background303841 -LV0x10 -Multi -WantF2 XM W" . PercentageToScreenWidth(25) . " H" . PercentageToScreenHeight(30), ["Chosen Index(ID)", "Duplicate Group of Indexes(ID)", "Relative Offset From Body", "Size",""])
Gui_ConflictSolver_DuplicateLV_Colors := LV_Colors(Gui_ConflictSolver_DuplicateLV) ; Create a new instance of LV_Colors
If !IsObject(Gui_ConflictSolver_DuplicateLV_Colors)
   MsgBox("Couldn't create a new LV_Colors object!", "ERROR", 16)
Gui_ConflictSolver_DuplicateLV_Colors.ShowColors(True)
Gui_ConflictSolver_DuplicateLV_Menu := Menu()
Gui_ConflictSolver_DuplicateLV.OnEvent("DoubleClick", Gui_ConflictSolver_DuplicateLV_Menu_Show)
Gui_ConflictSolver_DuplicateLV.OnEvent("ColClick", Gui_ConflictSolver_DuplicateLV_UpdateColors)

Gui_ConflictSolver_ContainerLV := Gui_ConflictSolver.AddListView("Grid Background303841 Checked -LV0x10 -Multi -WantF2 X+m YP W" . PercentageToScreenWidth(25) . " H" . PercentageToScreenHeight(30), ["Container Index(ID)", "Contained Group of Indexes(ID)", "Relative Offset From Body", "Size",""])
Gui_ConflictSolver_ContainerLV_Colors := LV_Colors(Gui_ConflictSolver_ContainerLV) ; Create a new instance of LV_Colors
If !IsObject(Gui_ConflictSolver_ContainerLV_Colors)
   MsgBox("Couldn't create a new LV_Colors object!", "ERROR", 16)
Gui_ConflictSolver_ContainerLV_Colors.ShowColors(True)
Gui_ConflictSolver_ContainerLV.OnEvent("ItemCheck", Gui_ConflictSolver_ContainerLV_ItemCheck)
Gui_ConflictSolver_ContainerLV.OnEvent("ColClick", Gui_ConflictSolver_ContainerLV_UpdateColors)

Gui_ConflictSolver_DuplicateLV.GetPos(&ctrlposX, &ctrlposY)
Gui_ConflictSolver_OverlapLV := Gui_ConflictSolver.AddListView("Grid Background303841 Checked -LV0x10 -Multi -WantF2 X" . ctrlposX . " Y" . ctrlposY . " W" . PercentageToScreenWidth(50.5) . " H" . PercentageToScreenHeight(30), ["Index", "Overlapped Group of Indexes", "Relative Offset From Body", "Size",""])
Gui_ConflictSolver_OverlapLV_Colors := LV_Colors(Gui_ConflictSolver_OverlapLV) ; Create a new instance of LV_Colors
If !IsObject(Gui_ConflictSolver_OverlapLV_Colors)
   MsgBox("Couldn't create a new LV_Colors object!", "ERROR", 16)
Gui_ConflictSolver_OverlapLV_Colors.ShowColors(True)
Gui_ConflictSolver_OverlapLV.OnEvent("ItemCheck", Gui_ConflictSolver_OverlapLV_ItemCheck)
Gui_ConflictSolver_OverlapLV.OnEvent("ColClick", Gui_ConflictSolver_OverlapLV_UpdateColors)
Gui_ConflictSolver.OnEvent("Close", ConflicSolver_Submit)
ConflictSolver_ChangeMode(0)
	; ~~~~~~~~~~~~~~~~~~~~~~~~~~~
return

Gui_ControlPanel_HowToUseMsg(GuiObj, Info)
{
	MsgBox("
(
1) Click Add Target Archives to List then select the MIX Archives you wish to analyze.
1.1) You can optionally delete a multiple rows on the MIX ListView by Right-Clicking them, then press Delete.
2) Put a Check Mark at the MIX Archives you wish to reMIX.
3) Change the reMIX "Mode" depending on your needs:
    * 1: File Size will not be reduced. The File Names will not be recovered. Only The Header will be recovered. 
    * 2(Recommended): File Size will not be reduced. The Header will be recovered, and will try to recover some File Names inside the Target MIX Archive.
    * 3(Advanced): File Size will be reduced. The Header will be recovered, and will try to recover some File Names inside the Target MIX Archive.
4) Press "reMIX all Targets" button.
4.1) Keep in mind that there is NO guarantee that ALL file names will be recovered. Some file names could still not show properly.
5) Wait for the reMIXing to Finish.
6) Each Successfully reMIXed File can be found at the same directory as its original file. The name will start with word reMIXed_<originalfilename>


For more Information about this Tool, Visit:
https://github.com/Aldrin-John-Olaer-Manalansan/RA2YR-reMIXer

If you have problems/errors/concerns/suggestions when using this tool, create an issue at:
https://github.com/Aldrin-John-Olaer-Manalansan/RA2YR-reMIXer/issues
)", "How to Use RA2YR reMIXer?", "Owner" . Gui_ControlPanel.Hwnd)
}

DragAndDropMIXesToList(GuiObj, GuiCtrlObj, SelectedFiles, X, Y)
{
	if (GuiCtrlObj == Gui_ControlPanel["LV"])
		AddMIXesToTargetList(SelectedFiles)
}

ComputeOutputFileSize(LookUpTable)
{
	OutputFileSize := (LookUpTable.Count * 12) + 10
	For Key in LookUpTable
		OutputFileSize += LookUpTable[Key].Size
	return OutputFileSize
}

ChangeBytesConflictText(OutputSize, MaxSize)
{
	RemainingSize := MaxSize - OutputSize
	Gui_ConflictSolver["BytesConflict"].Value := "MIX Size Before/After Reconstruction: " . OutputSize . " / " . MaxSize . " ("
	if (RemainingSize < 0)
	{
		Gui_ConflictSolver["BytesConflict"].SetFont("cRed bold")
		Gui_ConflictSolver["BytesConflict"].Value .= -RemainingSize . " Bytes Overflowed"
	}
	else
	{
		Gui_ConflictSolver["BytesConflict"].SetFont("c00FF7F bold")
		if (RemainingSize > 0)
			Gui_ConflictSolver["BytesConflict"].Value .= RemainingSize . " Bytes Reduced"
		else Gui_ConflictSolver["BytesConflict"].Value := "File Size Unchanged"
	}
	Gui_ConflictSolver["BytesConflict"].Value .= ")"
}

ConflictSolver_ChangeMode(Mode)
{
	if Mode
	{
		Gui_ConflictSolver_DuplicateLV.Enabled := False
		Gui_ConflictSolver_DuplicateLV.Visible := False
		Gui_ConflictSolver_ContainerLV.Enabled := False
		Gui_ConflictSolver_ContainerLV.Visible := False
		Gui_ConflictSolver_OverlapLV.Enabled := True
		Gui_ConflictSolver_OverlapLV.Visible := True
		Gui_ConflictSolver["BytesConflict"].Visible := True
	}
	else
	{
		Gui_ConflictSolver_DuplicateLV.Enabled := True
		Gui_ConflictSolver_DuplicateLV.Visible := True
		Gui_ConflictSolver_ContainerLV.Enabled := True
		Gui_ConflictSolver_ContainerLV.Visible := True
		Gui_ConflictSolver_OverlapLV.Enabled := False
		Gui_ConflictSolver_OverlapLV.Visible := False
		Gui_ConflictSolver["BytesConflict"].Visible := False
	}
}

Gui_ConflictSolver_CancelMIXReconstruction_OnClick(GuiObj := "", Info := "")
{
	Gui_ConflictSolver.Hide()
	global Gui_ConflictSolver_Status := -1
}

Gui_ControlPanel_LV_UpdateColors(*)
{
	Gui_ControlPanel["LV"].Opt("-Redraw")
	Gui_ControlPanel_LV_Colors.UpdateProps() ; sync LV info to the CLV
	Loop Gui_ControlPanel["LV"].GetCount()
	{
		GetColorFromStatus(Gui_ControlPanel["LV"].GetText(A_Index,1),&Color_BG,&Color_TX)
		Gui_ControlPanel_LV_Colors.Cell(A_Index, 1, Color_BG, Color_TX)
		GetColorFromStatus(Gui_ControlPanel["LV"].GetText(A_Index,2),&Color_BG,&Color_TX)
		Gui_ControlPanel_LV_Colors.Cell(A_Index, 2, Color_BG, Color_TX)
	}
	Gui_ControlPanel["LV"].Opt("+Redraw")
}

Gui_ConflictSolver_OverlapLV_ItemCheck(GuiCtrlObj, Row, Checked)
{
	if Checked and (Gui_ConflictSolver_OverlapLV.GetText(Row,2) == "")
	{ ; if this row was already settled
		Gui_ConflictSolver_OverlapLV.Modify(Row, "-Check")
		return
	}
	Gui_ConflictSolver_OverlapLV.Opt("-Redraw")
	ConflictMap := PublicAPIValue()
	GarbageMap := Map()
	OutputFileSize := ComputeOutputFileSize(ConflictMap.LookUpTable)
	Loop Gui_ConflictSolver_OverlapLV.GetCount()
	{
		if (Gui_ConflictSolver_OverlapLV.GetNext(A_Index-1,"C") == A_Index)
		{
			Key1 := Gui_ConflictSolver_OverlapLV.GetText(A_Index,1)
			Key1 := SubStr(Key1, 1, InStr(Key1, "(")-1)+0
			GarbageMap[Key1] := True
			OutputFileSize -= ConflictMap.LookUpTable[Key1].Size
		}
	}
	ChangeBytesConflictText(OutputFileSize, ConflictMap.MaxSize)
	Gui_ConflictSolver_OverlapLV_Colors.UpdateProps() ; sync LV info to the CLV
	Loop Gui_ConflictSolver_OverlapLV.GetCount()
	{
		if (Gui_ConflictSolver_OverlapLV.GetNext(A_Index-1,"C") == A_Index)
		{
			Gui_ConflictSolver_OverlapLV.Modify(A_Index, "Col2", "")
			Gui_ConflictSolver_OverlapLV_Colors.Row(A_Index, 0x00FF7F, 0x000000)
		}
		else
		{
			Key1 := Gui_ConflictSolver_OverlapLV.GetText(A_Index,1)
			Key1 := SubStr(Key1, 1, InStr(Key1, "(")-1)+0
			IndexesGroup := ""
			For Key2 in ConflictMap.OverlapMap[Key1]
			{
				if !GarbageMap.Has(Key2)
				{
					if (IndexesGroup != "")
						IndexesGroup .= "  ,  "
					IndexesGroup .= Key2 . "(" . Format("{:08X}",ConflictMap.LookUpTable[Key2].ID) . ")"
				}
			}
			Gui_ConflictSolver_OverlapLV.Modify(A_Index, "Col2", IndexesGroup)
			if (IndexesGroup == "")
				Gui_ConflictSolver_OverlapLV_Colors.Row(A_Index, 0x00FF7F, 0x000000)
			else Gui_ConflictSolver_OverlapLV_Colors.Row(A_Index, 0xFF0000, 0xFFFFFF)
		}
	}
	Loop Gui_ConflictSolver_OverlapLV.GetCount("Column") - 1
			Gui_ConflictSolver_OverlapLV.ModifyCol(A_Index, "AutoHdr Center")
	Gui_ConflictSolver_OverlapLV.Opt("+Redraw")
}

Gui_ConflictSolver_OverlapLV_UpdateColors(*)
{
	Gui_ConflictSolver_OverlapLV_Colors.UpdateProps() ; sync LV info to the CLV
	Loop Gui_ConflictSolver_OverlapLV.GetCount()
	{
		if (Gui_ConflictSolver_OverlapLV.GetText(A_Index,2) == "")
			Gui_ConflictSolver_OverlapLV_Colors.Row(A_Index, 0x00FF7F, 0x000000)
		else Gui_ConflictSolver_OverlapLV_Colors.Row(A_Index, 0xFF0000, 0xFFFFFF)
	}
}

Gui_ConflictSolver_ContainerLV_ItemCheck(GuiCtrlObj, Row, Checked)
{
	Gui_ConflictSolver_ContainerLV_Colors.UpdateProps() ; sync LV info to the CLV
	Gui_ConflictSolver_ContainerLV_Colors.Row(Row, Checked?0xFF8B00:0xFFD700, 0x000000)
}

Gui_ConflictSolver_ContainerLV_UpdateColors(*)
{
	Gui_ConflictSolver_ContainerLV.Opt("-Redraw")
	Gui_ConflictSolver_ContainerLV_Colors.UpdateProps() ; sync LV info to the CLV
	Loop Gui_ConflictSolver_ContainerLV.GetCount()
		Gui_ConflictSolver_ContainerLV_Colors.Row(A_Index, (Gui_ConflictSolver_ContainerLV.GetNext(A_Index-1,"C") == A_Index)?0xFF8B00:0xFFD700, 0x000000)
	Gui_ConflictSolver_ContainerLV.Opt("+Redraw")
}

Gui_ConflictSolver_DuplicateLV_UpdateColors(*)
{
	Gui_ConflictSolver_DuplicateLV.Opt("-Redraw")
	Gui_ConflictSolver_DuplicateLV_Colors.UpdateProps() ; sync LV info to the CLV
	Loop Gui_ConflictSolver_DuplicateLV.GetCount()
	{
		if IsInteger(Gui_ConflictSolver_DuplicateLV.GetText(A_Index,1))
			Gui_ConflictSolver_DuplicateLV_Colors.Row(A_Index, 0x00FF7F, 0x000000)
		else Gui_ConflictSolver_DuplicateLV_Colors.Row(A_Index, 0xFF0000, 0xFFFFFF)
	}
	Gui_ConflictSolver_DuplicateLV.Opt("+Redraw")
}

Gui_ConflictSolver_DuplicateLV_Menu_Show(LV, Row)
{
	if Row
	{
		Gui_ConflictSolver_DuplicateLV_Menu.Delete()
		Loop Parse Gui_ConflictSolver_DuplicateLV.GetText(Row,2), ",", A_Space
			Gui_ConflictSolver_DuplicateLV_Menu.Add(A_LoopField, Gui_ConflictSolver_DuplicateLV_SelectIndex, "BarBreak")
		MouseGetPos &X, &Y
		Gui_ConflictSolver_DuplicateLV_Menu.Show(X, Y)
	}
}

Gui_ConflictSolver_DuplicateLV_SelectIndex(ItemName, ItemPos, MyMenu)
{
	Row := Gui_ConflictSolver_DuplicateLV.GetNext()
	Gui_ConflictSolver_DuplicateLV.Modify(Row, "-Select Col1", ItemName)
	Gui_ConflictSolver_DuplicateLV.ModifyCol(1, "AutoHdr Integer Center")
	Gui_ConflictSolver_DuplicateLV_Colors.UpdateProps() ; sync LV info to the CLV
	Gui_ConflictSolver_DuplicateLV_Colors.Row(Row, 0x00FF7F, 0x000000)
}

AddMIXesToTargetList(SelectedFiles)
{
	if (SelectedFiles.Length > 0)
	{
		Gui_ControlPanel.Opt("+Disabled")
		Gui_ControlPanel_Progress.Value := 0
		Gui_ControlPanel_Progress.Opt("Range0-" . SelectedFiles.Length * 4)
		Gui_ControlPanel_Progress.Visible := True

		DuplicateChecker := ""
		RowCount := Gui_ControlPanel["LV"].GetCount()
		Loop RowCount
			DuplicateChecker .= "<|>" . Gui_ControlPanel["LV"].GetText(A_Index,3)
		Loop SelectedFiles.Length
		{
			if !InStr(DuplicateChecker, "<|>" . SelectedFiles[A_Index])
			{
				Gui_ControlPanel["LV"].Add(, , , SelectedFiles[A_Index])
				Gui_ControlPanel_LV_Colors.UpdateProps() ; sync LV info to the CLV
				Gui_ControlPanel["LV"].ModifyCol(3, "AutoHdr Text Left")
				RowCount++
				MixFileObj := FileRead(SelectedFiles[A_Index], "RAW")

				MixHeaderStatus := GetMixHeaderStatus(&MixFileObj)
				Gui_ControlPanel["LV"].Modify(RowCount, "Col1", MixHeaderStatus)
				Gui_ControlPanel["LV"].ModifyCol(1, "AutoHdr Text Center")
				GetColorFromStatus(Gui_ControlPanel["LV"].GetText(RowCount,1),&Color_BG,&Color_TX)
				Gui_ControlPanel_LV_Colors.Cell(RowCount, 1, Color_BG, Color_TX)
				Gui_ControlPanel_LV_Colors.UpdateProps() ; sync LV info to the CLV

				LMDStatus := GetLMDStatus(&MixFileObj)
				Gui_ControlPanel["LV"].Modify(
					RowCount,
					(((MixHeaderStatus == LMDStatus) and (MixHeaderStatus == "Healthy")) or InStr(MixHeaderStatus, "Unknown"))
					? "Col2"
					: "Check Col2"
					, LMDStatus)
				Gui_ControlPanel["LV"].ModifyCol(2, "AutoHdr Text Center")
				GetColorFromStatus(Gui_ControlPanel["LV"].GetText(RowCount,2),&Color_BG,&Color_TX)
				Gui_ControlPanel_LV_Colors.Cell(RowCount, 2, Color_BG, Color_TX)
				Gui_ControlPanel_LV_Colors.UpdateProps() ; sync LV info to the CLV
			}
		}

		Gui_ControlPanel_Progress.Visible := False
		Gui_ControlPanel.Opt("-Disabled")
		Gui_ControlPanel.Show()
		Gui_ControlPanel_LV_Colors.UpdateProps() ; sync LV info to the CLV
	}
}

AddMIXtoList(GuiObj := "", Info := "")
{
	SelectedFiles := FileSelect("M3", , "Select Target Archives")
	AddMIXesToTargetList(SelectedFiles)
}

Gui_ControlPanel_LV_Menu_Show(LV, Item, IsRightClick, X, Y)
{
	Gui_ControlPanel_LV_Menu.Show(X, Y)
}

Gui_ControlPanel_LV_DeleteRows(*)
{
	Count := Gui_ControlPanel["LV"].GetCount()
	if (Count > 0)
	{
		Gui_ControlPanel["LV"].Opt("-Redraw")
		Loop Count
		{
			Index := Count-A_Index+1
			if (Gui_ControlPanel["LV"].GetNext(Index-1) == Index)
				Gui_ControlPanel["LV"].Delete(Index)
		}
		Gui_ControlPanel_LV_Colors.UpdateProps() ; sync LV info to the CLV
		Gui_ControlPanel["LV"].Opt("+Redraw")
	}
}

reMIXAllMIXTargets(GuiObj, Info)
{
	Gui_ControlPanel.Opt("+Disabled")
	Count := Gui_ControlPanel["LV"].GetCount()
	Gui_ControlPanel_Progress.Visible := True
	Gui_ControlPanel_Progress.Value := 0
	reMIX_Mode := Gui_ControlPanel["ModeSelector"].Value
	CheckedCount := 0
	Loop Count
	{
		if (Gui_ControlPanel["LV"].GetNext(A_Index-1,"C") == A_Index)
			CheckedCount++
	}
	if (reMIX_Mode == 1)
		Gui_ControlPanel_Progress.Opt("Range0-" . CheckedCount * 2)
	else if (reMIX_Mode == 2)
		Gui_ControlPanel_Progress.Opt("Range0-" . CheckedCount * 8)
	else if (reMIX_Mode == 3)
		Gui_ControlPanel_Progress.Opt("Range0-" . CheckedCount * 11)
	Loop Count
	{
		Index := Count-A_Index+1
		if (Gui_ControlPanel["LV"].GetNext(Index-1,"C") == Index)
		{
			Status := reMIX_Level_%reMIX_Mode%(Gui_ControlPanel["LV"].GetText(Index,3))
			if (Status == -1) ; the user tells us to cancel reconstruction but instead just build the MIX File
				Status := reMIX_Level_2(Gui_ControlPanel["LV"].GetText(Index,3))
			if Status
			{
				Gui_ControlPanel["LV"].Delete(Index)
				Gui_ControlPanel_LV_Colors.UpdateProps() ; sync LV info to the CLV
			}
		}
	}
	Gui_ControlPanel_Progress.Visible := False
	Gui_ControlPanel.Opt("-Disabled")
	Gui_ControlPanel.Show()
	Gui_ControlPanel_LV_Colors.UpdateProps() ; sync LV info to the CLV
}

ConflicSolver_Submit(GuiObj)
{
	isSettled := True
	if Gui_ConflictSolver_OverlapLV.Visible
	{
		Loop Gui_ConflictSolver_OverlapLV.GetCount()
		{
			if (Gui_ConflictSolver_OverlapLV.GetText(A_Index,2) != "")
			{
				isSettled := False
				SetTimer ReOpenConflictSolver, -250
				break
			}
		}
	}
	else
	{
		Loop Gui_ConflictSolver_DuplicateLV.GetCount()
		{
			if (Gui_ConflictSolver_DuplicateLV.GetText(A_Index,1) == "")
			{
				isSettled := False
				SetTimer ReOpenConflictSolver, -250
				break
			}
		}
	}
	if isSettled
		global Gui_ConflictSolver_Status := False
}

ReOpenConflictSolver()
{
	Gui_ConflictSolver.Show("Center")
	Msgbox "There are still rows that you still haven't settled yet(Marked with Red Color). Choose a specific index among the duplicate group by Double-Clicking a Row with Red Color.", "Unsettled Duplicates Detected!", "Owner" . Gui_ConflictSolver.Hwnd
}

LMDSelector_Select(GuiObj)
{
	SelectedRow := Gui_LMDSelector_LV.GetNext()
	if !SelectedRow
		SelectedRow := LMDSelector_AutoPick()
	Address := Gui_LMDSelector_LV.GetText(SelectedRow)+0
	if (Address != "")
	{
		Gui_LMDSelector.Hide()
		PublicAPIValue(Address)
	}
}

PublicAPIValue(NewValue := "")
{
	static Value := 0
	if (NewValue != "")
		Value := NewValue
	return Value
}

LMDSelector_AutoPick()
{
	SelectedRow := 0
	Highest_RowIndex := 1
	Highest_Offset := 0
	Loop Gui_LMDSelector_LV.GetCount()
	{
		if (Gui_LMDSelector_LV.GetText(A_Index,4) == "Default")
		{
			SelectedRow := A_Index
			break
		}
		Count := Gui_LMDSelector_LV.GetText(A_Index,1)
		if (Highest_Offset < Count)
		{
			Highest_Offset := Count
			Highest_RowIndex := A_Index
		}
	}
	if !SelectedRow
		SelectedRow := Highest_RowIndex
	return SelectedRow
}

reMIX_Level_1(FileName)
{ ; Fix Header
	MixFileObj := FileRead(FileName, "RAW")
	if !IsObject(MixFileObj)
	{
		msgbox "Failed to Read MIX Archive:`n" . FileName
		return false
	}
	Gui_ControlPanel_Progress.Value++
		; ~~~~~~~~~~~~~~~~~~~~~~~~~~~ Fix Header
	NumPut("UInt", 0x00000000, MixFileObj)
	NumPut("UInt", MixFileObj.Size - 10 - (12 * NumGet(MixFileObj, 4, "UShort")), MixFileObj, 6)
		; ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	FromOldFilePath_SaveFuffer_ToNewFilePath(&FileName,&MixFileObj)
	Gui_ControlPanel_Progress.Value++
	return true
}

reMIX_Level_2(FileName)
{ ; Recover LMD File at Lookup Table -> Fix Header
	MixFileObj := FileRead(FileName, "RAW")
	if !IsObject(MixFileObj)
	{
		msgbox "Failed to Read MIX Archive:`n" . FileName
		return false
	}
	Gui_ControlPanel_Progress.Value++

	#IncludeAgain "Lib\GetMixInformations.ahk2" ; 4 progress value added after operation in this include

	if (LMDFile_OffsetfromBody.Length >= 1) and (LMDLookup.Length + InvalidInfo_Index.Length >= 1)
	{
		#IncludeAgain "Lib\LMDSelector_ChooseLMD.ahk2"
		NumPut("UInt", 0x366E051F, ; LMD ID
		       "UInt", File_StartingOffsetfromBody,
		       "UInt", NumGet(Area_Body_Ptr + File_StartingOffsetfromBody + 32, "UInt"), ; LMD Size
		       Area_Info_Ptr + ( 12 * ( ( LMDLookup.Length >= 1 ) ? LMDLookup[LMDLookup.Length].Index : InvalidInfo_Index[1] ) ) ) ; LMD LookUp Table Ptr
		Gui_ControlPanel_Progress.Value++
			; ~~~~~~~~~~~~~~~~~~~~~~~~~~~ Eliminate LMD Duplicates
		if (LMDLookup.Length >= 2)
		{
			RandomNumber := Buffer(4)
			Loop LMDLookup.Length - 1
			{
				Loop {
					NumPut("UInt", Random(0x0,0xFFFFFFFF), RandomNumber)
				} Until !InBin(Area_Info_Ptr, Area_Info_Size, RandomNumber.Ptr, 4)
				NumPut("UInt", NumGet(RandomNumber,"UInt"),
				       Area_Info_Ptr + ( 12 * LMDLookup[A_Index].Index ) ) ; LMD LookUp Table Ptr
			}
		}
		Gui_ControlPanel_Progress.Value++
			; ~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
	}
	else Gui_ControlPanel_Progress.Value += 2

		; ~~~~~~~~~~~~~~~~~~~~~~~~~~~ Fix Header
	NumPut("UInt", 0x00000000, MixFileObj)
	NumPut("UInt", Area_Body_Size, MixFileObj, 6)
		; ~~~~~~~~~~~~~~~~~~~~~~~~~~~

	FromOldFilePath_SaveFuffer_ToNewFilePath(&FileName,&MixFileObj)
	Gui_ControlPanel_Progress.Value++
	return true
}

reMIX_Level_3(FileName)
{ ; Reconstruct MIX Archive -> Recover LMD File at Lookup Table -> Fix Header
	MixFileObj := FileRead(FileName, "RAW")
	if !IsObject(MixFileObj)
	{
		msgbox "Failed to Read MIX Archive:`n" . FileName
		return false
	}
	reMIX_FileObj := Buffer(MixFileObj.Size)
	if !IsObject(reMIX_FileObj)
	{
		msgbox "Failed to Allocate Secondary Buffer:`n" . FileName
		return false
	}
	Gui_ControlPanel_Progress.Value++
	
	RedoreMIX:
	#IncludeAgain "Lib\GetMixInformations.ahk2" ; 4 progress value added after operation in this include

	/*
		Validate LookUpTable by Eliminating Garbage Informations:
		Case 1: one or more indexes have all their informations equal to each other. (ask user for help)
		Case 2: an index acting like a container was detected with one or more indexes inside it. (ask user for help)
		Case 3: an index overlaps with one or more indexes. (auto eliminate some garbage then ask user for help)
	*/
	if (LookUpTable.Count >= 2)
	{
			; ~~~~~~~~~~~~~~~~~~~~~~~~~~~ Stage 3: let user manually eliminate duplicate and contained cases.
		if ((DuplicateList.Length + ContainerMap.Count) > 0)
		{
			ConflictSolver_ChangeMode(0)
			Gui_ConflictSolver_DuplicateLV.Opt("-Redraw")
			Gui_ConflictSolver_ContainerLV.Opt("-Redraw")

			Gui_ConflictSolver_DuplicateLV.Delete()
			Gui_ConflictSolver_DuplicateLV_Colors.UpdateProps() ; sync LV info to the CLV
			Gui_ConflictSolver_DuplicateLV_Colors.Clear()
			Gui_ConflictSolver_ContainerLV.Delete()
			Gui_ConflictSolver_ContainerLV_Colors.UpdateProps() ; sync LV info to the CLV
			Gui_ConflictSolver_ContainerLV_Colors.Clear()

			Loop DuplicateList.Length
			{
				IndexesGroup := ""
				For Key in DuplicateList[A_Index]
				{
					if (A_Index > 1)
						IndexesGroup .= "  ,  "
					IndexesGroup .= Key . "(" . ID2Name(LookUpTable[Key].ID, &LMDMap) . ")"
				}
				Gui_ConflictSolver_DuplicateLV.Add("", , IndexesGroup, Format("0x{:08X}",LookUpTable[DuplicateList[A_Index][1]].OffsetfromBody), LookUpTable[DuplicateList[A_Index][1]].Size)
				Gui_ConflictSolver_DuplicateLV_Colors.UpdateProps() ; sync LV info to the CLV
				Gui_ConflictSolver_DuplicateLV_Colors.Row(A_Index, 0xFF0000, 0xFFFFFF)
			}
			Gui_ConflictSolver_DuplicateLV.ModifyCol(3, ,"Relative Offset From Body(" . Format("0x{:X}",Area_Body_Offset) . ")")
			Loop Gui_ConflictSolver_DuplicateLV.GetCount("Column") - 1
				Gui_ConflictSolver_DuplicateLV.ModifyCol(A_Index, "AutoHdr Center")
			For Key1 in ContainerMap
			{
				IndexesGroup := ""
				For Key2 in ContainerMap[Key1]
				{
					if (A_Index > 1)
						IndexesGroup .= "  ,  "
					IndexesGroup .= Key2 . "(" . ID2Name(LookUpTable[Key2].ID, &LMDMap) . ")"
				}
				Gui_ConflictSolver_ContainerLV.Add("", Key1 . "(" . ID2Name(LookUpTable[Key1].ID, &LMDMap) . ")", IndexesGroup, Format("0x{:X}",LookUpTable[Key1].OffsetfromBody), LookUpTable[Key1].Size)
				Gui_ConflictSolver_ContainerLV_Colors.UpdateProps() ; sync LV info to the CLV
				Gui_ConflictSolver_ContainerLV_Colors.Row(A_Index, 0xFFD700, 0x000000)
			}
			Gui_ConflictSolver_ContainerLV.ModifyCol(3, ,"Relative Offset From Body(" . Format("0x{:X}",Area_Body_Offset) . ")")
			Loop Gui_ConflictSolver_ContainerLV.GetCount("Column") - 1
				Gui_ConflictSolver_ContainerLV.ModifyCol(A_Index, "AutoHdr Center")
			Gui_ConflictSolver_Comment.Value := DuplicateList.Length . " Duplicate Informations and " . ContainerMap.Count . " Contained Indexes Group have been Detected inside:`n" . FileName . "
(


What is the case about Duplicate Informations?
* When two or more File ID's(found at the Lookup Table) have the same OffsetFromBody and FileSize. reMIXer will be confused on choosing which one among these File ID's is correct. File ID is important as this is the representation of the File's Name itself. So when a WRONG File ID was assigned for this File then the game will fail to recognize this file as it is interpreted with a different File Name(due to a different File ID). This could cause the Game to Crash if the Correct File ID wasn't Selected. So its important that you select which one of them is correct File ID.

What is the case about Group Contained Conflict?
* When the file territory of one or more File ID's(Contained) was found inside the file territory of another File ID(Container). The reMIXer cannot decide if the Container is a garbage information, or if the contained ones are garbage informations. Deleting a Correct File Information while Including Wrong File Informations will crash the game so be sure to correctly settle your checked/unchecked choices.


To Settle all Duplicate Informations:
    1) Double-Click a Specific Row you wish to Settle.
    2) Select the File Index that you think is the GENUINE DATA among the Group.
    2.1) The rest who are unselected inside this Group will be marked as GARBAGE/CORRUPTED DATA, deleting it in our Lookup Table.
    2.2) Keep in mind that selecting a WRONG File Index(therefore getting deleted) will assign a garbage name to this file. The Game will CRASH if this file's real name is needed to be used.
    3) Repeat this process to all fields marked with RED Color.

To Settle all Group Contained Conflicts:
    * Providing a Row with Check Mark will treat only the Container File Index(Column 1) as GARBAGE/CORRUPTED DATA, deleting it in our Lookup Table.
    * Providing a Row with Uncheck Mark will treat all file indexes inside the Contained Group(Column 2) as GARBAGE/CORRUPTED DATA, deleting it in our Lookup Table.
    * Keep in mind that settling a WRONG Choice(therefore getting deleted). The Game will CRASH if this File Index were originally being used but is now missing.


If you do not want to continue helping this tool settle the file information conflicts, click the Cancel MIX Reconstruction button. Keep in mind that will perform Level 2 Mode of Operation for this MIX Archive.

Close this Window once you've finished settling the Duplicate and Container Conflicts.	
)"

			Gui_ConflictSolver_DuplicateLV.Opt("+Redraw")
			Gui_ConflictSolver_ContainerLV.Opt("+Redraw")
			global Gui_ConflictSolver_Status := True
			Gui_ConflictSolver.Show("Center")
			Loop
			{
				sleep 1
				if (Gui_ConflictSolver_Status == -1)
				{
					Gui_ControlPanel.Show()
					Gui_ControlPanel_LV_Colors.UpdateProps() ; sync LV info to the CLV
					return Gui_ConflictSolver_Status
				}
				else if !Gui_ConflictSolver_Status
					break

			}
			Gui_ControlPanel.Show()
			Gui_ControlPanel_LV_Colors.UpdateProps() ; sync LV info to the CLV
			Loop Gui_ConflictSolver_DuplicateLV.GetCount()
			{
				Key := Gui_ConflictSolver_DuplicateLV.GetText(A_Index,1)
				Loop Parse Gui_ConflictSolver_DuplicateLV.GetText(A_Index,2), ",", A_Space
				{
					if (A_LoopField != Key)
					{
						Key1 := A_LoopField
						#IncludeAgain "Lib\RemoveGarbageToLookupTable.ahk2"
					}
				}
			}
			Loop Gui_ConflictSolver_ContainerLV.GetCount()
			{
				if (Gui_ConflictSolver_ContainerLV.GetNext(A_Index-1,"C") == A_Index)
				{ ; Remove File Index acting as a Container
					Key1 := Gui_ConflictSolver_ContainerLV.GetText(A_Index,1)
					#IncludeAgain "Lib\RemoveGarbageToLookupTable.ahk2"
				}
				else
				{ ; Remove Contained File Indexes
					Loop Parse Gui_ConflictSolver_ContainerLV.GetText(A_Index,2), ",", A_Space
					{
						Key1 := A_LoopField
						#IncludeAgain "Lib\RemoveGarbageToLookupTable.ahk2"
					}
				}
			}
		}
		DuplicateList := "" ; free memory
		ContainerMap := "" ; free memory
		Gui_ControlPanel_Progress.Value++
			; ~~~~~~~~~~~~~~~~~~~~~~~~~~~
		
			; ~~~~~~~~~~~~~~~~~~~~~~~~~~~ Stage 4: Analyze then Eliminate Garbage Informations
		OverlapMap_Garbage := Map()
		while (OverlapMap.Count > 0)
		{
			OverlappedFilesCount_Min := 0x7FFFFFFF
			OverlappedFilesCount_Max := 0
			For Key in OverlapMap
			{
				OverlappedFilesCount_Min := Min(OverlappedFilesCount_Min, OverlapMap[Key].Count)
				OverlappedFilesCount_Max := Max(OverlappedFilesCount_Max, OverlapMap[Key].Count)
			}
			if (OverlappedFilesCount_Min == OverlappedFilesCount_Max) ; We only have one Type of Garbage Level remaining among all indexes.
				break
				; ~~~~~~~~~~~~~~~~~~~~~~~~~~~ Collect All Files with the Highest Garbage Level
			OverlapMap_Garbage.Clear()
			For Key in OverlapMap
			{
				if (OverlapMap[Key].Count == OverlappedFilesCount_Max)
					OverlapMap_Garbage[Key] := OverlapMap[Key]
			}
				; ~~~~~~~~~~~~~~~~~~~~~~~~~~~
			For Key1 in OverlapMap_Garbage
			{ ; eliminate garbage files
				For Key2 in OverlapMap_Garbage[Key1]
				{
					if OverlapMap.Has(Key2)
					{
						if OverlapMap[Key2].Has(Key1) and (OverlapMap[Key2].Count < OverlappedFilesCount_Max)
						{
							if (OverlapMap[Key2].Count >= 2)
								OverlapMap[Key2].Delete(Key1)
							else OverlapMap.Delete(Key2)
						}
					}
				}
				;Eliminate Garbage File
				LookUpTable.Delete(Key1)
				OverlapMap.Delete(Key1)
			}
		}
		Gui_ControlPanel_Progress.Value++
			; ~~~~~~~~~~~~~~~~~~~~~~~~~~~

			; ~~~~~~~~~~~~~~~~~~~~~~~~~~~ Stage 5: Ask user to manually eliminate overlap garbage files
		if OverlapMap.Count
		{
			ConflictSolver_ChangeMode(1)
			Gui_ConflictSolver_OverlapLV.Opt("-Redraw")

			Gui_ConflictSolver_OverlapLV.Delete()
			Gui_ConflictSolver_OverlapLV_Colors.UpdateProps() ; sync LV info to the CLV
			Gui_ConflictSolver_OverlapLV_Colors.Clear()

			For Key1 in OverlapMap
			{
				IndexesGroup := ""
				For Key2 in OverlapMap[Key1]
				{
					if (A_Index > 1)
						IndexesGroup .= "  ,  "
					IndexesGroup .= Key2 . "(" . ID2Name(LookUpTable[Key2].ID, &LMDMap) . ")"
				}
				Gui_ConflictSolver_OverlapLV.Add("", Key1 . "(" . ID2Name(LookUpTable[Key1].ID, &LMDMap) . ")", IndexesGroup, Format("0x{:X}",LookUpTable[Key1].OffsetfromBody), LookUpTable[Key1].Size)
				Gui_ConflictSolver_OverlapLV_Colors.UpdateProps() ; sync LV info to the CLV
				Gui_ConflictSolver_OverlapLV_Colors.Row(A_Index, 0xFF0000, 0xFFFF00)
			}
			Gui_ConflictSolver_OverlapLV.ModifyCol(3, ,"Relative Offset From Body(" . Format("0x{:X}",Area_Body_Offset) . ")")
			Loop Gui_ConflictSolver_OverlapLV.GetCount("Column") - 1
				Gui_ConflictSolver_OverlapLV.ModifyCol(A_Index, "AutoHdr Center")

			Gui_ConflictSolver_Comment.Value := OverlapMap.Count . " Overlapping File Informations have been Detected inside:`n" . FileName . "
(


What is the case about Overlapping Conflicts?
* When the file territory of a certain File ID is overlapping one or more File ID's territory. The reMIXer cannot decide if the Overlapping file is a garbage information. Deleting a Correct File Information while Including Wrong File Informations will crash the game so be sure to correctly settle your checked/unchecked choices.


To Settle all Overlapping Conflicts:
* Providing a Row with Check Mark will treat the Overlapping Index(Column 1) as GARBAGE/CORRUPTED DATA, deleting it in our Lookup Table.
* Providing a Row with UnCheck Mark will treat the Overlapping Index(Column 1) as a GENUINE DATA, maintaining it in our Lookup Table.
* Keep in mind that settling a WRONG Choice(therefore getting deleted):
	- This tool could throw an error afterwards telling you to redo your settlement with the conflicts.
	- Else if this tool didn't detect your mistake then the Game will CRASH if this File Index were originally being used but is now missing.


If you do not want to continue helping this tool settle the file information conflicts, click the Cancel MIX Reconstruction button. Keep in mind that will perform Level 2 Mode of Operation for this MIX Archive.

Close this Window once all rows are marked as with green color.
)"
			OutputFileSize := ComputeOutputFileSize(LookUpTable)
			ChangeBytesConflictText(OutputFileSize, MixFileObj.Size)
			Gui_ConflictSolver_OverlapLV.Opt("+Redraw")
			global Gui_ConflictSolver_Status := True
			PublicAPIValue({OverlapMap:OverlapMap,LookUpTable:LookUpTable,MaxSize:MixFileObj.Size})
			Gui_ConflictSolver.Show("Center")
			Loop
			{
				sleep 1
				if (Gui_ConflictSolver_Status == -1)
				{
					Gui_ControlPanel.Show()
					Gui_ControlPanel_LV_Colors.UpdateProps() ; sync LV info to the CLV
					return Gui_ConflictSolver_Status
				}
				else if !Gui_ConflictSolver_Status
					break

			}
			Gui_ControlPanel.Show()
			Gui_ControlPanel_LV_Colors.UpdateProps() ; sync LV info to the CLV
			Loop Gui_ConflictSolver_OverlapLV.GetCount()
			{
				if (Gui_ConflictSolver_OverlapLV.GetNext(A_Index-1,"C") == A_Index)
				{
					Key := Gui_ConflictSolver_OverlapLV.GetText(A_Index,1)
					if LookUpTable.Has(Key)
						LookUpTable.Delete(Key)
				}
			}
		}
		OverlapMap := "" ; free memory
		Gui_ControlPanel_Progress.Value++
			; ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	}
	else Gui_ControlPanel_Progress.Value += 3
		; ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	reMIX_Area_Info_Offset := 0xA
	reMIX_Area_Info_Ptr := reMIX_FileObj.Ptr + Area_Info_Offset
	reMIX_Files_Count := LookUpTable.Count + 1 ; +1 for the LMD info region
	reMIX_Area_Info_Size := reMIX_Files_Count * 12 ; incase we detected a Corrupted LMD Info, then we add additional 12 bytes size to our new MIX Archive for our LMD Info
	reMIX_Area_Body_Offset := reMIX_Area_Info_Size + reMIX_Area_Info_Offset
	reMIX_Area_Body_Size := 0
	reMIX_Area_Body_MaxAllowedSize := reMIX_FileObj.Size - reMIX_Area_Body_Offset
	reMIX_Area_Body_Ptr := reMIX_FileObj.Ptr + reMIX_Area_Body_Offset

		; ~~~~~~~~~~~~~~~~~~~~~~~~~~~ reconstruct the LMD Information Field
	if (LMDMap.Count > 0)
	{ ; reconstruct LMD File
		reMIX_Seeker := reMIX_Area_Body_Ptr + 52 ; pointer to dictionary list
		For Key in LMDMap
		{
			StrPut(LMDMap[Key], reMIX_Seeker, "UTF-8")
			reMIX_Seeker += StrLen(LMDMap[Key]) + 1
		}
		File_Size := reMIX_Seeker - reMIX_Area_Body_Ptr
		DllCall("MSVCRT.dll\memcpy", "Ptr", reMIX_Area_Body_Ptr, "Ptr", LMD_Header_Pattern, "UInt", 32, "CDecl Ptr") ; set LMD header
		NumPut("UInt", File_Size, ; Size
			   "UInt", 0x00000000, ; Padding
			   "UInt", 0x00000000, ; Padding
			   "UInt", 0x00000005, ; GameType == RA2/RA2YR/TS/TD
			   "UInt", LMDMap.Count, ; Names Count
			   reMIX_Area_Body_Ptr + 32)
			; set LMD Info at Lookup Table
		NumPut("UInt", 0x366E051F, ; ID
			   "UInt", 0x00000000, ; OffsetFromBody
			   "UInt", File_Size, ; Size
			   reMIX_Area_Info_Ptr)
	}
	else if (!LMDFile_OffsetfromBody.Length) ; No LMD File inside the Mix
		NumPut("UInt", 0x366E051F, "UInt", 0xFFFFFFFF, "UInt", 0x00000000, reMIX_Area_Info_Ptr)
	else
	{ ; use the level 2 method of recovering LMD File
		Seeker := Area_Info_Ptr
		reMIX_Seeker := reMIX_Area_Info_Ptr
		#IncludeAgain "Lib\LMDSelector_ChooseLMD.ahk2"
		File_ID := 0x366E051F ; LMD ID
		File_Ptr := Area_Body_Ptr + File_StartingOffsetfromBody
		File_Size := NumGet(File_Ptr+32, "UInt")
		#IncludeAgain "Lib\MigrateFileToNewMixFile.ahk2"
	}
	LMDMap := "" ; Free Memory
	Gui_ControlPanel_Progress.Value++
		; ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	LookUpTable_Count := LookUpTable.Count
	if IsObject(LookUpTable_Buffer)
		LookUpTable_Buffer.Size := LookUpTable_Count * 2
	else LookUpTable_Buffer := Buffer(LookUpTable_Count * 2)
	Seeker := LookUpTable_Buffer.Ptr
	For Key in LookUpTable
	{
		NumPut("UShort", Key, Seeker)
		Seeker += 2
	}
	LookUpTable := "" ; Free Memory

	starttime := A_TickCount
	FileSize := DllCall(ReconstructMIX,
				 "Ptr"   , MixFileObj.Ptr,
				 "Ptr"   , reMIX_FileObj.Ptr,
				 "UInt"  , reMIX_FileObj.Size,
				 "Ptr"   , LookUpTable_Buffer.Ptr,
				 "UShort", LookUpTable_Count,
				 "CDecl UInt")
	if !FileSize
	{
		if (MsgBox("MIX Archive reconstruction has encountered an error:`n" . FileName . "`n`nThis happens when you wrongfully settled file conflicts at the Conflict Solver Interface.`n`nTry to reMIX this file again and be sure to properly settle the file conflicts.`n`nWould you like to redo the conflict settlement?", "reMIXer Error", 20) == "Yes")
			goto RedoreMIX
		return false
	}
	reMIX_FileObj.Size := FileSize ; shrink the mix file
	Gui_ControlPanel_Progress.Value++

	FromOldFilePath_SaveFuffer_ToNewFilePath(&FileName,&reMIX_FileObj)
	Gui_ControlPanel_Progress.Value++
	return true
}

ID2Name(ID, &LMDMap)
{
	return (LMDMap.Has(ID) ? LMDMap[ID] : Format("{:08X}",ID))
}

FromOldFilePath_SaveFuffer_ToNewFilePath(&Path,&Mix_Buffer)
{
	SplitPath Path, &OutFileName, &OutDir
	FilePath := OutDir . "\reMIXed_" . OutFileName
	if FileExist(FilePath)
	{
		Loop
		{
			FilePath := OutDir . "\reMIXed" . A_Index . "_" . OutFileName
			if !FileExist(FilePath)
				break
		}
	}
	FileAppend Mix_Buffer, FilePath, "RAW"
}

GetLMDStatus(&MixFileObj)
{
	#IncludeAgain "Lib\GetMixInformations.ahk2" ; 4 progress value added after operation in this include
	if LookUpTable.Count
	{
		RecoveryPercentage := 0
		For Key in LookUpTable
		{
			if LMDMap.Has(LookUpTable[Key].ID)
				RecoveryPercentage++
		}
		RecoveryPercentage :=  100.00 * RecoveryPercentage / LookUpTable.Count
	}
	else RecoveryPercentage := 0
	if !LMDFile_OffsetfromBody.Length or (RecoveryPercentage == 0) ; no LMD file detected
		return "Unrecoverable"
	else if (LMDLookup.Length >= 1) ; LMD is considered Healthy if we found its info
	{
		LMDStatus := Format("{:.2f}", RecoveryPercentage) . "% Recoverable"
		Loop LMDLookup.Length
		{
			if LMDLookup[A_Index].isHealthy
				LMDStatus := "Healthy"
		}
		return LMDStatus
	}
	else if (InvalidInfo_Index.Length >= 1)
		return Format("{:.2f}", RecoveryPercentage) . "% Recoverable"
	else return RecoveryPercentage Format("{:.2f}", RecoveryPercentage) . "% Reconstructable"
}

GetMixHeaderStatus(&MixFileObj)
{
	EncryptionKey := NumGet(MixFileObj, "UShort")
	if (EncryptionKey)
		return Format("Unknown 0x{:X}", EncryptionKey)
	return (NumGet(MixFileObj, 6, "UInt") == (MixFileObj.Size - 10 - (12 * NumGet(MixFileObj, 4, "UShort")))) ? "Healthy" : "Recoverable"
}

GetColorFromStatus(Status,&Color_BG,&Color_TX)
{
	Switch
	{
		case (Status == "Healthy"):
			Color_BG := 0x00FF7F
			Color_TX := 0x000000
		case InStr(Status, "Reconstructable",True):
			Color_BG := 0xFF8B00
			Color_TX := 0x000000
		case InStr(Status, "Recoverable",True):
			Color_BG := 0xFFD700
			Color_TX := 0x000000
		default:
			Color_BG := 0xFF0000
			Color_TX := 0xFFFFFF
	}
}

PercentageToScreenWidth(Percentage)
{
	return Percentage * (A_ScreenWidth / 100)
}

PercentageToScreenHeight(Percentage)
{
	return Percentage * (A_ScreenHeight / 100)
}

#include "Lib\InBin.ahk2"
#include "Lib\StringToCRC32.ahk2"